[
    {
        "id": "function-aggregate",
        "type": "function",
        "z": "eccd60802d954cb5",
        "name": "Agregador de sensores (valida\u00e7\u00e3o com null)",
        "func": "\n// Lista dos sensores esperados\nconst sensores = [\"pm10\", \"pm25\", \"o3\", \"no2\", \"so2\", \"co\", \"temperatura\", \"umidade\", \"pressao\"];\n\n// \u00cdndice atual do buffer\nlet index = flow.get(\"index\") || 0;\n\n// Dados de entrada acumulados\nlet buffers = flow.get(\"buffers\") || {};\nbuffers[msg.topic] = msg.payload;\nflow.set(\"buffers\", buffers);\n\n// Verifica se todos os buffers foram carregados\nif (sensores.every(s => Array.isArray(buffers[s]))) {\n\n    // Verifica se todos os sensores possuem algum dado no \u00edndice atual\n    let timestamp = null;\n    if (buffers[\"pm25\"] && buffers[\"pm25\"][index]) {\n        timestamp = buffers[\"pm25\"][index].timestamp;\n    } else {\n        // N\u00e3o h\u00e1 timestamp de refer\u00eancia -> aguarda pr\u00f3ximo ciclo\n        return null;\n    }\n\n    // Monta o registro \u00fanico\n    let registro = { timestamp };\n\n    sensores.forEach(sensor => {\n        let valor = null;\n\n        if (Array.isArray(buffers[sensor]) && buffers[sensor][index]) {\n            valor = buffers[sensor][index].valor;\n        }\n\n        registro[sensor] = valor; // Mesmo que seja null\n    });\n\n    // Atualiza \u00edndice\n    flow.set(\"index\", index + 1);\n\n    msg.payload = registro;\n    return msg;\n}\n\nreturn null;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "x": 1020,
        "y": 480,
        "wires": [
            [
                "debug-sim",
                "mqtt-out"
            ]
        ]
    }
]